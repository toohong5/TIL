# 01_알고리즘

1주마다 1장씩 진행.(월 : 교재내용 공부 + 실습문제 1개 / 화: 실습(실습문제 4개 + 추가문제 1개))

추상자료형(Abstract Data Type)

문제풀때 라이브러리 사용하지 않는다.(List 사용할때...max(), min(), sort() 등등 사용하지 않기, 슬라이싱도 사용하지 않기)

이차원배열리스트 사용법 익숙해지기!! => IM





## 1. 배열(Array)

### 1) 알고리즘

- 컴퓨터가 어떤일을 수행하기 위한 단계적 방법
- 어떠한 문제를 해결하기 위한 절차

- 좋은 알고리즘?

  - 정확성
  - 작업량(시간): CPU를 얼마나 많이 사용하는가, CPU 점유하는 시간 길수록 계산 오래걸림. CPU최대한 적게 쓰도록 하는게 좋음
  - 메모리 : 얼마나 적은 메모리 사용하는가
  - 단순성 : 얼마나 단순한가
  - 최적성 : 더 이상 개선할 여지 없이 최적화 되었는가

- 알고리즘의 성능측정

  - 시간효율성, 공간효율성 이 얼마나 좋은가..

  - 시간복잡도 : 알고리즘의 작업량 표현함. 실제 걸리는 시간을 측정한다. 실행되는 명령문의 개수를 계산함. (복잡도 높으면 시간 상대적으로 많이 걸림)

    ```python
    def func(n):
        # 실행문 1번
        for i in range(n):
            # 실행문 - n번
            for j in range(i, n):
                # 실행문 - x번
    # 실행문 반복횟수 : a*n^2 + b*n + c
    ```

    - 시간복잡도 = 빅-오(O)표기법
      - 시간복잡도 함수 중에서 가장 큰 영향력을 주는  n에 대한 항(최고차항)만을 표시
      - 계수는 생략하여 표시
      - O( ) : 최악의 경우
      - 오메가( ) : 최선의 경우
      - 세타( ) : 빅오와 오메가가 같을 때..
      - 찾으려는 key값에 따라서 최선 1 최악 n 만큼 돌 수도 있음...
      - 빅 오를 가장 많이 사용함(최악의 경우를 가장 많이 사용)
    - 이진탐색
    - O(1) : 항상시간이 일정(증가하지 않는다.) => 최고의 방법인데 거의 없음.
    - 시간이 오래걸리면 어려운 문제임.(상대적으로쉬운문제는 P집합? 어려운문제는 NP집합?)

### 2) 배열이란...

- 동일한 자료형들의 덩어리를 저장하기 위한 자료구조.
- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

#### 2-1) 1차원 배열의 선언과 접근

```python
Arr = list()
# 또는
Arr[]

Arr[0] = 10 # 배열 Arr의 0번째 원소에 10을 저장하라.
```

- 리스트를 이용해 스택이나 큐 사용시 별로 안좋음?

### 3) 정렬

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰값(오름차순) 혹은 그 반대의 순서대로(내림차순) 재배열하는 것.

- `버블정렬(Bubble Sort)` : 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

  - 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
  - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품모양과 같다고 하여 버블정렬이라고 한다.
  - 시간 복잡도 : O(n^2)
  - n-1번 간다...?

  ```python
  arr = [55, 7, 78, 12, 42]
  n = len(arr)
  for i in range(n -1):
      if arr[i] > arr[i + 1]:
          arr[i], arr[i+1] = arr[i+1], arr[i] # 크면 자리 바꾸기
  print(arr)
  for i in range(n - 2): # i가 가야할 범위를 줄임 -> n-1번 반복하면 됨!!
      if arr[i] > arr[i + 1]:
          arr[i], arr[i+1] = arr[i+1], arr[i] # 크면 자리 바꾸기
  print(arr)
  #--------------------------------------------------------------
  # 중첩for문 이용
  arr = [55, 7, 78, 12, 42]
  n = len(arr)
  
  for j in range(n - 1, 0, 1):
      for i in range(j):
          if arr[i] > arr[i + 1]: # 부등호 바꾸면 내림차순됨.
          arr[i], arr[i+1] = arr[i+1], arr[i]
  ```

- 선택정렬 : 최대, 최소를 찾는다. 맨 처음 만나는 값을 최소나 최대로 기억하고 비교한다.

  ```python
  arr = [55, 7, 78, 12, 42]
  
  MIN = arr[0] # 처음 값을 최소값으로 설정
  for i in range(1, len(arr)):
      if arr[i] < MIN:
          MIN = arr[i]
  # n-1번 반복하면 된다.        
  print(MIN)
  
  # 인덱스를 알아야 자리를 바꿀 수 있음...
  
  MIN = 0
  for i in range(MIN+1, len(arr)):
      if arr[i] < arr[MIN]:
          MIN =i
  arr[0], arr[MIN] = arr[MIN], arr[0] #자리 바꿔준다.
  print(arr)
  
  MIN = 1 # 0번째는 끝났으니 그 다음부터 시작함.
  for i in range(MIN+1, len(arr)):
      if arr[i] < arr[MIN]:
          MIN = i
  arr[1], arr[MIN] = arr[MIN], arr[1] #자리 바꿔준다.
  print(arr)
  
  # n-1 번 반복한다...0, 1, 2, ...n-2까지..
  
  for j in range(len(arr) - 2):
      MIN = j # 최소값 설정.
      for i in range(j+1, len(arr)):
          if arr[i] < arr[MIN]:
              MIN = i
      arr[j], arr[MIN] = arr[MIN], arr[j]
  print(arr)
  ```

  

- `카운팅 정렬(Counting Sort)` : 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇개씩 있는지 세는 작업을 하여, 선형시간에 정렬하는 효율적인 알고리즘.

  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용가능..
  - 공간을 할당하려면 집합내의 가장 큰 정수를 알아야한다.
  - 시간복잡도 :  O(n + k), n: 리스트의 길이(자료의 개수), k: 정수의 최대값

  ```python
  data = [0, 3, 1, 3, 1, 2, 4, 1]
  counts = [0] * 5 # 최대값 = 4
  
  for val in data:
      counts[val] += 1
  
  sorted = []
  for i in range(len(counts)):
      for j in range(count[i]):
          sorted.append(i) # 빈도수 만큼 들어감...
          
  print(counts)
  
  # 정석적인 풀이
  
  for i in range(1, len(counts)):
      counts[i] = counts[i -1] + counts[i]
      
  # 누적빈도수 => 
  # 0,1,2,3,4
  # 1,4,5,6,8 : 끝이 2가 되는 경우가 5개있다?
  """
  data  =  0 4 1 3 1 2 4 1 
  counts=  1 3 5 6 8
  temp  =        1  
  """
  ```

  

- <연습문제 1> p.16

  ```python
  data = [7, 4, 2, 0, 0, 6, 0, 7, 0] # 상자들이 쌓여있는 높이
  # 제일꼭대기의 상자 낙폭만 계산하면 된다?
  # 
  ```

- <Baby-gin Game> p.19 => 결정문제유형(답이 두 가지 중 하나)

- 최적화 문제 : 최대 혹은 최소가 되는 경우를 찾는 문제

- 완전검색 잘하면 a형 풀수있데

- `완전검색(Exausitive Search)` _ 중요!!!!!!!

  - 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다.
  - Brute-force 혹은 generate-and-test 기법이라고도 불리운다.
  - 모든 경우의 수를 테스트 한 후, 최종해법을 도출한다
  - 일반적으로 경우의 수가 상대적으로 작을 때 유용함.
  - 수행속도는 느리지만 해답을 찾아내지 못할 확률이 작다.

```python
data = 'ABC'

# 중복순열
n = len(data)
for i in range(n):
    for j in range(n):
        for k in range(n):
            print(data[i], data[j], data[k])
            
# 중복안나오게 하기...            
n = len(data)
for i in range(n):
    for j in range(n):
       	if i== j: continue # i==j이면 건너뜀
        for k in range(n):
            if i == k or j == k: continue
            print(data[i], data[j], data[k])
```

